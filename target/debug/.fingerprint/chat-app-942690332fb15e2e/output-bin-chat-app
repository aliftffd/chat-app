{"$message_type":"diagnostic","message":"visibility `pub` is not followed by an item","code":null,"level":"error","spans":[{"file_name":"src/server.rs","byte_start":354,"byte_end":357,"line_start":12,"line_end":12,"column_start":1,"column_end":4,"is_primary":true,"text":[{"text":"pub Struct ChatServer{","highlight_start":1,"highlight_end":4}],"label":"the visibility","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you likely meant to define an item, e.g., `pub fn foo() {}`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: visibility `pub` is not followed by an item\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/server.rs:12:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub Struct ChatServer{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe visibility\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you likely meant to define an item, e.g., `pub fn foo() {}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected item, found `Struct`","code":null,"level":"error","spans":[{"file_name":"src/server.rs","byte_start":358,"byte_end":364,"line_start":12,"line_end":12,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"pub Struct ChatServer{","highlight_start":5,"highlight_end":11}],"label":"expected item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected item, found `Struct`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/server.rs:12:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub Struct ChatServer{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected item\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Expected `arg` attribute instead of `command`","code":null,"level":"error","spans":[{"file_name":"src/main.rs","byte_start":218,"byte_end":225,"line_start":11,"line_end":11,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    #[command(Subcommand)]","highlight_start":7,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: Expected `arg` attribute instead of `command`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:11:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[command(Subcommand)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `tokio::io::AsyncBuffReadExt`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":92,"byte_end":108,"line_start":4,"line_end":4,"column_start":17,"column_end":33,"is_primary":true,"text":[{"text":"use tokio::io::{AsyncBuffReadExt,BufReader};","highlight_start":17,"highlight_end":33}],"label":"no `AsyncBuffReadExt` in `io`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":92,"byte_end":108,"line_start":4,"line_end":4,"column_start":17,"column_end":33,"is_primary":true,"text":[{"text":"use tokio::io::{AsyncBuffReadExt,BufReader};","highlight_start":17,"highlight_end":33}],"label":null,"suggested_replacement":"AsyncBufReadExt","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `tokio::io::AsyncBuffReadExt`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:4:17\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse tokio::io::{AsyncBuffReadExt,BufReader};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `AsyncBuffReadExt` in `io`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `AsyncBufReadExt`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `chrono`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":3380,"byte_end":3386,"line_start":102,"line_end":102,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"            let timestamp = chrono::DateTime::from_timestamp(msg.timestamp as i64,0)","highlight_start":29,"highlight_end":35}],"label":"use of unresolved module or unlinked crate `chrono`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `chrono`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:102:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let timestamp = chrono::DateTime::from_timestamp(msg.timestamp as i64,0)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `chrono`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `MessageType` in `message`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":3598,"byte_end":3609,"line_start":108,"line_end":108,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Text => {","highlight_start":33,"highlight_end":44}],"label":"could not find `MessageType` in `message`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":3598,"byte_end":3609,"line_start":108,"line_end":108,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Text => {","highlight_start":33,"highlight_end":44}],"label":null,"suggested_replacement":"Message_type","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `MessageType` in `message`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:108:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                crate::message::MessageType::Text => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `MessageType` in `message`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: an enum with a similar name exists: `Message_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `MessageType` in `message`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":3884,"byte_end":3895,"line_start":117,"line_end":117,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Join => {","highlight_start":33,"highlight_end":44}],"label":"could not find `MessageType` in `message`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":3884,"byte_end":3895,"line_start":117,"line_end":117,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Join => {","highlight_start":33,"highlight_end":44}],"label":null,"suggested_replacement":"Message_type","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `MessageType` in `message`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:117:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                crate::message::MessageType::Join => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `MessageType` in `message`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: an enum with a similar name exists: `Message_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `MessageType` in `message`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":4177,"byte_end":4188,"line_start":125,"line_end":125,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Leave => {","highlight_start":33,"highlight_end":44}],"label":"could not find `MessageType` in `message`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":4177,"byte_end":4188,"line_start":125,"line_end":125,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"                crate::message::MessageType::Leave => {","highlight_start":33,"highlight_end":44}],"label":null,"suggested_replacement":"Message_type","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `MessageType` in `message`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:125:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                crate::message::MessageType::Leave => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `MessageType` in `message`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: an enum with a similar name exists: `Message_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `MessageType` in `message`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":4470,"byte_end":4481,"line_start":133,"line_end":133,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"                 crate::message::MessageType::System => {","highlight_start":34,"highlight_end":45}],"label":"could not find `MessageType` in `message`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":4470,"byte_end":4481,"line_start":133,"line_end":133,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"                 crate::message::MessageType::System => {","highlight_start":34,"highlight_end":45}],"label":null,"suggested_replacement":"Message_type","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `MessageType` in `message`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:133:34\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                 crate::message::MessageType::System => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `MessageType` in `message`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: an enum with a similar name exists: `Message_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected type, found module `self`","code":{"code":"E0573","explanation":"Something other than a type has been used when one was expected.\n\nErroneous code examples:\n\n```compile_fail,E0573\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon::Born { // error!\n    Dragon::Born\n}\n\nconst HOBBIT: u32 = 2;\nimpl HOBBIT {} // error!\n\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(_: Wizard::Saruman); // error!\n}\n```\n\nIn all these errors, a type was expected. For example, in the first error, if\nwe want to return the `Born` variant from the `Dragon` enum, we must set the\nfunction to return the enum and not its variant:\n\n```\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon { // ok!\n    Dragon::Born\n}\n```\n\nIn the second error, you can't implement something on an item, only on types.\nWe would need to create a new type if we wanted to do something similar:\n\n```\nstruct Hobbit(u32); // we create a new type\n\nconst HOBBIT: Hobbit = Hobbit(2);\nimpl Hobbit {} // ok!\n```\n\nIn the third case, we tried to only expect one variant of the `Wizard` enum,\nwhich is not possible. To make this work, we need to using pattern matching\nover the `Wizard` enum:\n\n```\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(w: Wizard) { // ok!\n        match w {\n            Wizard::Saruman => {\n                // do something\n            }\n            _ => {} // ignore everything else\n        }\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":295,"byte_end":299,"line_start":13,"line_end":13,"column_start":57,"column_end":61,"is_primary":true,"text":[{"text":"    pub async fn connect(addr: &str) -> std::io::Result<self>{","highlight_start":57,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a self type with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":295,"byte_end":299,"line_start":13,"line_end":13,"column_start":57,"column_end":61,"is_primary":true,"text":[{"text":"    pub async fn connect(addr: &str) -> std::io::Result<self>{","highlight_start":57,"highlight_end":61}],"label":null,"suggested_replacement":"Self","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0573]\u001b[0m\u001b[0m\u001b[1m: expected type, found module `self`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:13:57\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn connect(addr: &str) -> std::io::Result<self>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a self type with a similar name exists (notice the capitalization): `Self`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected value, found module `self`","code":{"code":"E0424","explanation":"The `self` keyword was used inside of an associated function without a \"`self`\nreceiver\" parameter.\n\nErroneous code example:\n\n```compile_fail,E0424\nstruct Foo;\n\nimpl Foo {\n    // `bar` is a method, because it has a receiver parameter.\n    fn bar(&self) {}\n\n    // `foo` is not a method, because it has no receiver parameter.\n    fn foo() {\n        self.bar(); // error: `self` value is a keyword only available in\n                    //        methods with a `self` parameter\n    }\n}\n```\n\nThe `self` keyword can only be used inside methods, which are associated\nfunctions (functions defined inside of a `trait` or `impl` block) that have a\n`self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\n`self: &mut Pin<Self>` (this last one is an example of an [\"arbitrary `self`\ntype\"](https://github.com/rust-lang/rust/issues/44874)).\n\nCheck if the associated function's parameter list should have contained a `self`\nreceiver for it to be a method, and add it if so. Example:\n\n```\nstruct Foo;\n\nimpl Foo {\n    fn bar(&self) {}\n\n    fn foo(self) { // `foo` is now a method.\n        self.bar(); // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":423,"byte_end":427,"line_start":16,"line_end":16,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":12,"highlight_end":16}],"label":"`self` value is a keyword only available in methods with a `self` parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":256,"byte_end":263,"line_start":13,"line_end":13,"column_start":18,"column_end":25,"is_primary":false,"text":[{"text":"    pub async fn connect(addr: &str) -> std::io::Result<self>{","highlight_start":18,"highlight_end":25}],"label":"this function doesn't have a `self` parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"add a `self` receiver parameter to make the associated `fn` a method","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":264,"byte_end":264,"line_start":13,"line_end":13,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"    pub async fn connect(addr: &str) -> std::io::Result<self>{","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"&self, ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0424]\u001b[0m\u001b[0m\u001b[1m: expected value, found module `self`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:16:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn connect(addr: &str) -> std::io::Result<self>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis function doesn't have a `self` parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(self, {stream})\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`self` value is a keyword only available in methods with a `self` parameter\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: add a `self` receiver parameter to make the associated `fn` a method\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub async fn connect(\u001b[0m\u001b[0m\u001b[38;5;10m&self, \u001b[0m\u001b[0maddr: &str) -> std::io::Result<self>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `message` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":2891,"byte_end":2898,"line_start":85,"line_end":85,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"            if message = \"/quit\"{","highlight_start":16,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might have meant to use pattern matching","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":2891,"byte_end":2891,"line_start":85,"line_end":85,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"            if message = \"/quit\"{","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":"let ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `message` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:85:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if message = \"/quit\"{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to use pattern matching\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if \u001b[0m\u001b[0m\u001b[38;5;10mlet \u001b[0m\u001b[0mmessage = \"/quit\"{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `message` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":3020,"byte_end":3027,"line_start":89,"line_end":89,"column_start":61,"column_end":68,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":61,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":3020,"byte_end":3027,"line_start":89,"line_end":89,"column_start":61,"column_end":68,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":61,"highlight_end":68}],"label":null,"suggested_replacement":"messages","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `message` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:89:61\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a local variable with a similar name exists: `messages`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected type, found module `self`","code":{"code":"E0573","explanation":"Something other than a type has been used when one was expected.\n\nErroneous code examples:\n\n```compile_fail,E0573\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon::Born { // error!\n    Dragon::Born\n}\n\nconst HOBBIT: u32 = 2;\nimpl HOBBIT {} // error!\n\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(_: Wizard::Saruman); // error!\n}\n```\n\nIn all these errors, a type was expected. For example, in the first error, if\nwe want to return the `Born` variant from the `Dragon` enum, we must set the\nfunction to return the enum and not its variant:\n\n```\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon { // ok!\n    Dragon::Born\n}\n```\n\nIn the second error, you can't implement something on an item, only on types.\nWe would need to create a new type if we wanted to do something similar:\n\n```\nstruct Hobbit(u32); // we create a new type\n\nconst HOBBIT: Hobbit = Hobbit(2);\nimpl Hobbit {} // ok!\n```\n\nIn the third case, we tried to only expect one variant of the `Wizard` enum,\nwhich is not possible. To make this work, we need to using pattern matching\nover the `Wizard` enum:\n\n```\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(w: Wizard) { // ok!\n        match w {\n            Wizard::Saruman => {\n                // do something\n            }\n            _ => {} // ignore everything else\n        }\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/message.rs","byte_start":876,"byte_end":880,"line_start":41,"line_end":41,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"    pub fn from_json(data: &self) -> Result<Self,serde_json::Error>{","highlight_start":29,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a self type with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/message.rs","byte_start":876,"byte_end":880,"line_start":41,"line_end":41,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"    pub fn from_json(data: &self) -> Result<Self,serde_json::Error>{","highlight_start":29,"highlight_end":33}],"label":null,"suggested_replacement":"Self","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0573]\u001b[0m\u001b[0m\u001b[1m: expected type, found module `self`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:41:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_json(data: &self) -> Result<Self,serde_json::Error>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a self type with a similar name exists (notice the capitalization): `Self`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary braces around function argument","code":{"code":"unused_braces","explanation":null},"level":"warning","spans":[{"file_name":"src/client.rs","byte_start":429,"byte_end":430,"line_start":16,"line_end":16,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":436,"byte_end":437,"line_start":16,"line_end":16,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_braces)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these braces","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":429,"byte_end":430,"line_start":16,"line_end":16,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/client.rs","byte_start":436,"byte_end":437,"line_start":16,"line_end":16,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary braces around function argument\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:16:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(self, {stream})\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_braces)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these braces\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        Ok(self, \u001b[0m\u001b[0m\u001b[38;5;9m{\u001b[0m\u001b[0mstream\u001b[0m\u001b[0m\u001b[38;5;9m}\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        Ok(self, stream)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type `Message_type` should have an upper camel case name","code":{"code":"non_camel_case_types","explanation":null},"level":"warning","spans":[{"file_name":"src/message.rs","byte_start":301,"byte_end":313,"line_start":16,"line_end":16,"column_start":10,"column_end":22,"is_primary":true,"text":[{"text":"pub enum Message_type{","highlight_start":10,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_camel_case_types)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to upper camel case","code":null,"level":"help","spans":[{"file_name":"src/message.rs","byte_start":301,"byte_end":313,"line_start":16,"line_end":16,"column_start":10,"column_end":22,"is_primary":true,"text":[{"text":"pub enum Message_type{","highlight_start":10,"highlight_end":22}],"label":null,"suggested_replacement":"MessageType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: type `Message_type` should have an upper camel case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:16:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum Message_type{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to upper camel case: `MessageType`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_camel_case_types)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this enum variant takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":423,"byte_end":427,"line_start":16,"line_end":16,"column_start":12,"column_end":16,"is_primary":false,"text":[{"text":"        Ok(self, {stream})","highlight_start":12,"highlight_end":16}],"label":"unexpected argument #1","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":420,"byte_end":422,"line_start":16,"line_end":16,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":9,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/usr/src/debug/rust/rustc-1.90.0-src/library/core/src/result.rs","byte_start":20921,"byte_end":20923,"line_start":552,"line_end":552,"column_start":5,"column_end":7,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":423,"byte_end":429,"line_start":16,"line_end":16,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"        Ok(self, {stream})","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this enum variant takes 1 argument but 2 arguments were supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:16:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(self, {stream})\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munexpected argument #1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/src/debug/rust/rustc-1.90.0-src/library/core/src/result.rs:552:5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the extra argument\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        Ok(\u001b[0m\u001b[0m\u001b[38;5;9mself, \u001b[0m\u001b[0m{stream})\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        Ok({stream})\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `read_line` found for struct `tokio::io::BufReader` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_buf_read_ext.rs","byte_start":7972,"byte_end":7981,"line_start":199,"line_end":199,"column_start":12,"column_end":21,"is_primary":false,"text":[{"text":"        fn read_line<'a>(&'a mut self, buf: &'a mut String) -> ReadLine<'a, Self>","highlight_start":12,"highlight_end":21}],"label":"the method is available for `tokio::io::BufReader<tokio::io::Stdin>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":1087,"byte_end":1096,"line_start":36,"line_end":36,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"                match stdin_reader.read_line(&mut line).await{","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"there is a method `read_i8` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_read_ext.rs","byte_start":1032,"byte_end":1092,"line_start":30,"line_end":30,"column_start":17,"column_end":77,"is_primary":true,"text":[{"text":"                fn $name(&mut self) -> $($fut)*<&mut Self> where Self: Unpin {","highlight_start":17,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_read_ext.rs","byte_start":12100,"byte_end":48788,"line_start":330,"line_end":1304,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        read_impl! {","highlight_start":9,"highlight_end":1},{"text":"            /// Reads an unsigned 8 bit integer from the underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u8(&mut self) -> io::Result<u8>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is cancel safe. If this method is used as an event in a","highlight_start":1,"highlight_end":1},{"text":"            /// [`tokio::select!`](crate::select) statement and some other branch","highlight_start":1,"highlight_end":1},{"text":"            /// completes first, it is guaranteed that no data were read.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 8 bit integers from an `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![2, 5]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(2, reader.read_u8().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(5, reader.read_u8().await?);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u8(&mut self) -> ReadU8;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads a signed 8 bit integer from the underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i8(&mut self) -> io::Result<i8>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is cancel safe. If this method is used as an event in a","highlight_start":1,"highlight_end":1},{"text":"            /// [`tokio::select!`](crate::select) statement and some other branch","highlight_start":1,"highlight_end":1},{"text":"            /// completes first, it is guaranteed that no data were read.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 8 bit integers from an `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x02, 0xfb]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(2, reader.read_i8().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(-5, reader.read_i8().await?);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i8(&mut self) -> ReadI8;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 16-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u16(&mut self) -> io::Result<u16>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 16 bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![2, 5, 3, 0]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(517, reader.read_u16().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(768, reader.read_u16().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u16(&mut self) -> ReadU16;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads a signed 16-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i16(&mut self) -> io::Result<i16>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 16 bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x00, 0xc1, 0xff, 0x7c]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(193, reader.read_i16().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(-132, reader.read_i16().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i16(&mut self) -> ReadI16;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 32-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u32(&mut self) -> io::Result<u32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 32-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x00, 0x00, 0x01, 0x0b]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(267, reader.read_u32().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u32(&mut self) -> ReadU32;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads a signed 32-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i32(&mut self) -> io::Result<i32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 32-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7a, 0x33]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(-34253, reader.read_i32().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i32(&mut self) -> ReadI32;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 64-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u64(&mut self) -> io::Result<u64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 64-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(918733457491587, reader.read_u64().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u64(&mut self) -> ReadU64;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an signed 64-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i64(&mut self) -> io::Result<i64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 64-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(i64::MIN, reader.read_i64().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i64(&mut self) -> ReadI64;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 128-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u128(&mut self) -> io::Result<u128>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 128-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///         0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,","highlight_start":1,"highlight_end":1},{"text":"            ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(16947640962301618749969007319746179, reader.read_u128().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u128(&mut self) -> ReadU128;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an signed 128-bit integer in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i128(&mut self) -> io::Result<i128>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 128-bit big-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0x80, 0, 0, 0, 0, 0, 0, 0,","highlight_start":1,"highlight_end":1},{"text":"            ///     0, 0, 0, 0, 0, 0, 0, 0","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(i128::MIN, reader.read_i128().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i128(&mut self) -> ReadI128;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an 32-bit floating point type in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_f32(&mut self) -> io::Result<f32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read 32-bit floating point type from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0xff, 0x7f, 0xff, 0xff]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(f32::MIN, reader.read_f32().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_f32(&mut self) -> ReadF32;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an 64-bit floating point type in big-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_f64(&mut self) -> io::Result<f64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read 64-bit floating point type from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(f64::MIN, reader.read_f64().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_f64(&mut self) -> ReadF64;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 16-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u16_le(&mut self) -> io::Result<u16>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 16 bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![2, 5, 3, 0]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(1282, reader.read_u16_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(3, reader.read_u16_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u16_le(&mut self) -> ReadU16Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads a signed 16-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i16_le(&mut self) -> io::Result<i16>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 16 bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x00, 0xc1, 0xff, 0x7c]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(-16128, reader.read_i16_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(31999, reader.read_i16_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i16_le(&mut self) -> ReadI16Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 32-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u32_le(&mut self) -> io::Result<u32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 32-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x00, 0x00, 0x01, 0x0b]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(184614912, reader.read_u32_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u32_le(&mut self) -> ReadU32Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads a signed 32-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i32_le(&mut self) -> io::Result<i32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 32-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7a, 0x33]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(863698943, reader.read_i32_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i32_le(&mut self) -> ReadI32Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 64-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u64_le(&mut self) -> io::Result<u64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 64-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(9477368352180732672, reader.read_u64_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u64_le(&mut self) -> ReadU64Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an signed 64-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i64_le(&mut self) -> io::Result<i64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 64-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(128, reader.read_i64_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i64_le(&mut self) -> ReadI64Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an unsigned 128-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_u128_le(&mut self) -> io::Result<u128>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read unsigned 128-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,","highlight_start":1,"highlight_end":1},{"text":"            ///     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(174826588484952389081207917399662330624, reader.read_u128_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_u128_le(&mut self) -> ReadU128Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an signed 128-bit integer in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_i128_le(&mut self) -> io::Result<i128>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read signed 128-bit little-endian integers from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0x80, 0, 0, 0, 0, 0, 0, 0,","highlight_start":1,"highlight_end":1},{"text":"            ///     0, 0, 0, 0, 0, 0, 0, 0","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(128, reader.read_i128_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_i128_le(&mut self) -> ReadI128Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an 32-bit floating point type in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_f32_le(&mut self) -> io::Result<f32>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read 32-bit floating point type from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![0xff, 0xff, 0x7f, 0xff]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(f32::MIN, reader.read_f32_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_f32_le(&mut self) -> ReadF32Le;","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Reads an 64-bit floating point type in little-endian order from the","highlight_start":1,"highlight_end":1},{"text":"            /// underlying reader.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Equivalent to:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```ignore","highlight_start":1,"highlight_end":1},{"text":"            /// async fn read_f64_le(&mut self) -> io::Result<f64>;","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// It is recommended to use a buffered reader to avoid excessive","highlight_start":1,"highlight_end":1},{"text":"            /// syscalls.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Errors","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method returns the same errors as [`AsyncReadExt::read_exact`].","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// [`AsyncReadExt::read_exact`]: AsyncReadExt::read_exact","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Cancel safety","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// This method is not cancellation safe. If the method is used as the","highlight_start":1,"highlight_end":1},{"text":"            /// event in a [`tokio::select!`](crate::select) statement and some","highlight_start":1,"highlight_end":1},{"text":"            /// other branch completes first, then some data may be lost.","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # Examples","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// Read 64-bit floating point type from a `AsyncRead`:","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// ```rust","highlight_start":1,"highlight_end":1},{"text":"            /// use tokio::io::{self, AsyncReadExt};","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// use std::io::Cursor;","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// # #[tokio::main(flavor = \"current_thread\")]","highlight_start":1,"highlight_end":1},{"text":"            /// # async fn main() -> io::Result<()> {","highlight_start":1,"highlight_end":1},{"text":"            /// let mut reader = Cursor::new(vec![","highlight_start":1,"highlight_end":1},{"text":"            ///     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff","highlight_start":1,"highlight_end":1},{"text":"            /// ]);","highlight_start":1,"highlight_end":1},{"text":"            ///","highlight_start":1,"highlight_end":1},{"text":"            /// assert_eq!(f64::MIN, reader.read_f64_le().await?);","highlight_start":1,"highlight_end":1},{"text":"            /// Ok(())","highlight_start":1,"highlight_end":1},{"text":"            /// # }","highlight_start":1,"highlight_end":1},{"text":"            /// ```","highlight_start":1,"highlight_end":1},{"text":"            fn read_f64_le(&mut self) -> ReadF64Le;","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"read_impl!","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_read_ext.rs","byte_start":795,"byte_end":817,"line_start":21,"line_end":21,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    macro_rules! read_impl {","highlight_start":5,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"trait `AsyncBufReadExt` which provides `read_line` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::message::ChatMessage;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio::io::AsyncBufReadExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `read_line` found for struct `tokio::io::BufReader` in the current scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:36:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                match stdin_reader.read_line(&mut line).await{\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_buf_read_ext.rs:199:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        fn read_line<'a>(&'a mut self, buf: &'a mut String) -> ReadLine<'a, Self>\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `tokio::io::BufReader<tokio::io::Stdin>` here\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `read_i8` with a similar name, but with different arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_read_ext.rs:330:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m330\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        read_impl! {\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            /// Reads an unsigned 8 bit integer from the underlying reader.\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m332\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ///\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            /// Equivalent to:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            fn read_f64_le(&mut self) -> ReadF64Le;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `read_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncBufReadExt` which provides `read_line` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use tokio::io::AsyncBufReadExt;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":1279,"byte_end":1296,"line_start":40,"line_end":40,"column_start":28,"column_end":45,"is_primary":true,"text":[{"text":"                        if content = \"/quit\" {","highlight_start":28,"highlight_end":45}],"label":"expected `bool`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might have meant to compare for equality","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":1288,"byte_end":1288,"line_start":40,"line_end":40,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"                        if content = \"/quit\" {","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":"=","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:40:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if content = \"/quit\" {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `bool`, found `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to compare for equality\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        if content =\u001b[0m\u001b[0m\u001b[38;5;10m=\u001b[0m\u001b[0m \"/quit\" {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `split` found for struct `tokio::net::tcp::ReadHalf` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":1827,"byte_end":1832,"line_start":56,"line_end":56,"column_start":56,"column_end":61,"is_primary":true,"text":[{"text":"            let (reader, _ ) = buf_reader.into_inner().split();","highlight_start":56,"highlight_end":61}],"label":"method not found in `tokio::net::tcp::ReadHalf<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `split` found for struct `tokio::net::tcp::ReadHalf` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:56:56\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let (reader, _ ) = buf_reader.into_inner().split();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `tokio::net::tcp::ReadHalf<'_>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `readline` found for struct `tokio::io::BufReader` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":2014,"byte_end":2022,"line_start":62,"line_end":62,"column_start":34,"column_end":42,"is_primary":true,"text":[{"text":"                match buf_reader.readline(&mut line).await {","highlight_start":34,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `read_line` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":2014,"byte_end":2022,"line_start":62,"line_end":62,"column_start":34,"column_end":42,"is_primary":true,"text":[{"text":"                match buf_reader.readline(&mut line).await {","highlight_start":34,"highlight_end":42}],"label":null,"suggested_replacement":"read_line","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `readline` found for struct `tokio::io::BufReader` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:62:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                match buf_reader.readline(&mut line).await {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `read_line` with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                match buf_reader.read\u001b[0m\u001b[0m\u001b[38;5;10m_\u001b[0m\u001b[0mline(&mut line).await {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `display_message` found for struct `ChatClient` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":2403,"byte_end":2418,"line_start":70,"line_end":70,"column_start":35,"column_end":50,"is_primary":true,"text":[{"text":"                            Self::display_message(&chat_msg);","highlight_start":35,"highlight_end":50}],"label":"function or associated item not found in `ChatClient`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":172,"byte_end":193,"line_start":8,"line_end":8,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct ChatClient {","highlight_start":1,"highlight_end":22}],"label":"function or associated item `display_message` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no function or associated item named `display_message` found for struct `ChatClient` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:70:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct ChatClient {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfunction or associated item `display_message` not found for this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            Self::display_message(&chat_msg);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item not found in `ChatClient`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `write_all` found for struct `tokio::net::tcp::WriteHalf` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_write_ext.rs","byte_start":13965,"byte_end":13974,"line_start":387,"line_end":387,"column_start":12,"column_end":21,"is_primary":false,"text":[{"text":"        fn write_all<'a>(&'a mut self, src: &'a [u8]) -> WriteAll<'a, Self>","highlight_start":12,"highlight_end":21}],"label":"the method is available for `tokio::net::tcp::WriteHalf<'_>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/client.rs","byte_start":2995,"byte_end":3004,"line_start":89,"line_end":89,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `AsyncWriteExt` which provides `write_all` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::message::ChatMessage;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio::io::AsyncWriteExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `write` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":2995,"byte_end":3004,"line_start":89,"line_end":89,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":"write","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `write_all` found for struct `tokio::net::tcp::WriteHalf` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:89:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.48.0/src/io/util/async_write_ext.rs:387:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m387\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        fn write_all<'a>(&'a mut self, src: &'a [u8]) -> WriteAll<'a, Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `tokio::net::tcp::WriteHalf<'_>` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncWriteExt` which provides `write_all` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use tokio::io::AsyncWriteExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `write` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m            if let Err(e) = writer.\u001b[0m\u001b[0m\u001b[38;5;9mwrite_all\u001b[0m\u001b[0m(format!(\"{}\\n\",message).as_byte()).await {\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m            if let Err(e) = writer.\u001b[0m\u001b[0m\u001b[38;5;10mwrite\u001b[0m\u001b[0m(format!(\"{}\\n\",message).as_byte()).await {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `as_byte` found for struct `std::string::String` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":3029,"byte_end":3036,"line_start":89,"line_end":89,"column_start":70,"column_end":77,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":70,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `as_bytes` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/client.rs","byte_start":3029,"byte_end":3036,"line_start":89,"line_end":89,"column_start":70,"column_end":77,"is_primary":true,"text":[{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":70,"highlight_end":77}],"label":null,"suggested_replacement":"as_bytes","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_byte` found for struct `std::string::String` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:89:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `as_bytes` with a similar name\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte\u001b[0m\u001b[0m\u001b[38;5;10ms\u001b[0m\u001b[0m()).await {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/client.rs","byte_start":500,"byte_end":4757,"line_start":19,"line_end":143,"column_start":55,"column_end":6,"is_primary":true,"text":[{"text":"    pub async fn run(&mut self) -> std::io::Result<()>{","highlight_start":55,"highlight_end":56},{"text":"        let (reader, mut writer) = self.stream.split();","highlight_start":1,"highlight_end":56},{"text":"        let mut buf_reader = BufReader::new(reader);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let (tx,mut rx) = mpsc::channel::<String>(100);","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        //Spawn task for reading user input","highlight_start":1,"highlight_end":44},{"text":"        let input_handle = tokio::spawn(async move {","highlight_start":1,"highlight_end":53},{"text":"            let stdin = tokio::io::stdin();","highlight_start":1,"highlight_end":44},{"text":"            let mut stdin_reader = BufReader::new(stdin);","highlight_start":1,"highlight_end":58},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            loop {","highlight_start":1,"highlight_end":19},{"text":"                print!(\"{}\", \"> \".green());","highlight_start":1,"highlight_end":44},{"text":"                io::stdout().flush().unwrap();","highlight_start":1,"highlight_end":47},{"text":"                line.clear();","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                match stdin_reader.read_line(&mut line).await{","highlight_start":1,"highlight_end":63},{"text":"                    Ok(0) => break,// EOF ","highlight_start":1,"highlight_end":43},{"text":"                    Ok(_) => {","highlight_start":1,"highlight_end":31},{"text":"                        let content = line.trim().to_string();","highlight_start":1,"highlight_end":63},{"text":"                        if content = \"/quit\" {","highlight_start":1,"highlight_end":47},{"text":"                            let _ = tx.send(content).await;","highlight_start":1,"highlight_end":60},{"text":"                            break;","highlight_start":1,"highlight_end":35},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if !content.is_empty(){","highlight_start":1,"highlight_end":48},{"text":"                            let _ = tx.send(content).await;","highlight_start":1,"highlight_end":60},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Err(_) => break,","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        });","highlight_start":1,"highlight_end":12},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Spawn task for receiving messages from server ","highlight_start":1,"highlight_end":58},{"text":"        let receive_handle = tokio::spawn(async move {","highlight_start":1,"highlight_end":55},{"text":"            let (reader, _ ) = buf_reader.into_inner().split();","highlight_start":1,"highlight_end":64},{"text":"            let buf_reader = BufReader::new(reader);","highlight_start":1,"highlight_end":53},{"text":"            let mut line = String::new();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            loop {","highlight_start":1,"highlight_end":19},{"text":"                line.clear();","highlight_start":1,"highlight_end":30},{"text":"                match buf_reader.readline(&mut line).await {","highlight_start":1,"highlight_end":61},{"text":"                    Ok(0) => {","highlight_start":1,"highlight_end":31},{"text":"                        println!(\"{}\", \" Connection closed by server\".red());","highlight_start":1,"highlight_end":79},{"text":"                        break;","highlight_start":1,"highlight_end":31},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(_) => {","highlight_start":1,"highlight_end":31},{"text":"                        let trimmed = line.trim();","highlight_start":1,"highlight_end":51},{"text":"                        if let Ok(chat_msg) = ChatMessage::from_json(trimmed){","highlight_start":1,"highlight_end":79},{"text":"                            Self::display_message(&chat_msg);","highlight_start":1,"highlight_end":62},{"text":"                        }else if !trimmed.is_empty(){","highlight_start":1,"highlight_end":54},{"text":"                            println!(\"{}\",trimmed);","highlight_start":1,"highlight_end":52},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Err(e) => {","highlight_start":1,"highlight_end":32},{"text":"                        eprintln!(\" Error reading from server: {}\",e);","highlight_start":1,"highlight_end":72},{"text":"                        break;","highlight_start":1,"highlight_end":31},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        });","highlight_start":1,"highlight_end":12},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        //Handle sending messages ","highlight_start":1,"highlight_end":35},{"text":"        while let Some(messages) = rx.recv().await{","highlight_start":1,"highlight_end":52},{"text":"            if message = \"/quit\"{","highlight_start":1,"highlight_end":34},{"text":"                break;","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            if let Err(e) = writer.write_all(format!(\"{}\\n\",message).as_byte()).await {","highlight_start":1,"highlight_end":88},{"text":"                eprintln!(\" Error sending message: {}\",e);","highlight_start":1,"highlight_end":60},{"text":"                break;","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            input_handle.abort();","highlight_start":1,"highlight_end":34},{"text":"            receive_handle.abort();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            println!(\" Disconnected from server\");","highlight_start":1,"highlight_end":52},{"text":"            Ok(());","highlight_start":1,"highlight_end":20},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fn display_message(msg: &ChatMessage){","highlight_start":1,"highlight_end":47},{"text":"            let timestamp = chrono::DateTime::from_timestamp(msg.timestamp as i64,0)","highlight_start":1,"highlight_end":85},{"text":"                .unwrap()","highlight_start":1,"highlight_end":26},{"text":"                .format(\"%H:%M:%S\")","highlight_start":1,"highlight_end":36},{"text":"                .to_string();","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            match msg.message_type{","highlight_start":1,"highlight_end":36},{"text":"                crate::message::MessageType::Text => {","highlight_start":1,"highlight_end":55},{"text":"                    println!(","highlight_start":1,"highlight_end":30},{"text":"                        \"{}{}{}\",","highlight_start":1,"highlight_end":34},{"text":"                        timestamp.dimmed(),","highlight_start":1,"highlight_end":44},{"text":"                        msg.username.blue(),","highlight_start":1,"highlight_end":45},{"text":"                        msg.content","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                crate::message::MessageType::Join => {","highlight_start":1,"highlight_end":55},{"text":"                    println!(","highlight_start":1,"highlight_end":30},{"text":"                        \"{} {} {}\",","highlight_start":1,"highlight_end":36},{"text":"                        timestamp.dimmed(),","highlight_start":1,"highlight_end":44},{"text":"                        \"\".green(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.content.yellow()","highlight_start":1,"highlight_end":45},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                crate::message::MessageType::Leave => {","highlight_start":1,"highlight_end":56},{"text":"                    println!(","highlight_start":1,"highlight_end":30},{"text":"                        \"{} {} {}\",","highlight_start":1,"highlight_end":36},{"text":"                        timestamp.dimmed(),","highlight_start":1,"highlight_end":44},{"text":"                        \"\".red(),","highlight_start":1,"highlight_end":36},{"text":"                        msg.content.yellow()","highlight_start":1,"highlight_end":45},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                 crate::message::MessageType::System => {","highlight_start":1,"highlight_end":58},{"text":"                    println!(","highlight_start":1,"highlight_end":30},{"text":"                        \"{} {} {}\",","highlight_start":1,"highlight_end":36},{"text":"                        timestamp.dimmed(),","highlight_start":1,"highlight_end":44},{"text":"                        \"\".cyan(),","highlight_start":1,"highlight_end":36},{"text":"                        msg.content.cyan()","highlight_start":1,"highlight_end":43},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                 }","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"expected `Result<(), Error>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `Result<(), std::io::Error>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/client.rs:19:55\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    pub async fn run(&mut self) -> std::io::Result<()>{\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _______________________________________________________^\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let (reader, mut writer) = self.stream.split();\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut buf_reader = BufReader::new(reader);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<(), Error>`, found `()`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m:   expected enum `\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<(), std::io::Error>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m            found unit type `\u001b[0m\u001b[0m\u001b[1m\u001b[35m()\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/message.rs","byte_start":70,"byte_end":79,"line_start":4,"line_end":4,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize)]","highlight_start":17,"highlight_end":26}],"label":"the trait `Serialize` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/message.rs","byte_start":70,"byte_end":79,"line_start":4,"line_end":4,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize)]","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/message.rs","byte_start":124,"byte_end":127,"line_start":7,"line_end":7,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub id: Uuid,","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `Uuid` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 131 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `message::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: serde::Serialize` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:4:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Serialize, Deserialize)]\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Serialize` is not implemented for `Uuid`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub id: Uuid,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `Uuid` type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Serialize`:\u001b[0m\n\u001b[0m               &'a T\u001b[0m\n\u001b[0m               &'a mut T\u001b[0m\n\u001b[0m               ()\u001b[0m\n\u001b[0m               (T,)\u001b[0m\n\u001b[0m               (T0, T1)\u001b[0m\n\u001b[0m               (T0, T1, T2)\u001b[0m\n\u001b[0m               (T0, T1, T2, T3)\u001b[0m\n\u001b[0m               (T0, T1, T2, T3, T4)\u001b[0m\n\u001b[0m             and 131 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `message::_::_serde::ser::SerializeStruct::serialize_field`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs:1917:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1915\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1916\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1917\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        T: ?Sized + Serialize;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/message.rs","byte_start":132,"byte_end":136,"line_start":7,"line_end":7,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"    pub id: Uuid,","highlight_start":13,"highlight_end":17}],"label":"the trait `Deserialize<'_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 145 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:7:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub id: Uuid,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Deserialize<'_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Deserialize<'de>`:\u001b[0m\n\u001b[0m               &'a Path\u001b[0m\n\u001b[0m               &'a [u8]\u001b[0m\n\u001b[0m               &'a str\u001b[0m\n\u001b[0m               ()\u001b[0m\n\u001b[0m               (T,)\u001b[0m\n\u001b[0m               (T0, T1)\u001b[0m\n\u001b[0m               (T0, T1, T2)\u001b[0m\n\u001b[0m               (T0, T1, T2, T3)\u001b[0m\n\u001b[0m             and 145 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `next_element`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1771:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1769\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1770\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1771\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        T: Deserialize<'de>,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/message.rs","byte_start":132,"byte_end":136,"line_start":7,"line_end":7,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"    pub id: Uuid,","highlight_start":13,"highlight_end":17}],"label":"the trait `Deserialize<'_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 145 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:7:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub id: Uuid,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Deserialize<'_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Deserialize<'de>`:\u001b[0m\n\u001b[0m               &'a Path\u001b[0m\n\u001b[0m               &'a [u8]\u001b[0m\n\u001b[0m               &'a str\u001b[0m\n\u001b[0m               ()\u001b[0m\n\u001b[0m               (T,)\u001b[0m\n\u001b[0m               (T0, T1)\u001b[0m\n\u001b[0m               (T0, T1, T2)\u001b[0m\n\u001b[0m               (T0, T1, T2, T3)\u001b[0m\n\u001b[0m             and 145 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `next_value`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1916:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1914\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn next_value<V>(&mut self) -> Result<V, Self::Error>\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1915\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1916\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        V: Deserialize<'de>,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `MapAccess::next_value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/message.rs","byte_start":81,"byte_end":92,"line_start":4,"line_end":4,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize)]","highlight_start":28,"highlight_end":39}],"label":"the trait `Deserialize<'_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/message.rs","byte_start":81,"byte_end":92,"line_start":4,"line_end":4,"column_start":28,"column_end":39,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize)]","highlight_start":28,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 145 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `message::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: serde::Deserialize<'de>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/message.rs:4:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Serialize, Deserialize)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Deserialize<'_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Uuid` type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Deserialize<'de>`:\u001b[0m\n\u001b[0m             &'a Path\u001b[0m\n\u001b[0m             &'a [u8]\u001b[0m\n\u001b[0m             &'a str\u001b[0m\n\u001b[0m             ()\u001b[0m\n\u001b[0m             (T,)\u001b[0m\n\u001b[0m             (T0, T1)\u001b[0m\n\u001b[0m             (T0, T1, T2)\u001b[0m\n\u001b[0m             (T0, T1, T2, T3)\u001b[0m\n\u001b[0m           and 145 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `message::_::_serde::__private228::de::missing_field`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs:26:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mwhere\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    V: Deserialize<'de>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `missing_field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":944,"byte_end":945,"line_start":38,"line_end":38,"column_start":65,"column_end":66,"is_primary":true,"text":[{"text":"            let server = server::ChatServer::new(&address).await?;","highlight_start":65,"highlight_end":66}],"label":"cannot use the `?` operator in an async block that returns `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":944,"byte_end":945,"line_start":38,"line_end":38,"column_start":65,"column_end":66,"is_primary":false,"text":[{"text":"            let server = server::ChatServer::new(&address).await?;","highlight_start":65,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":"this function should return `Result` or `Option` to accept `?`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[tokio::main]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-macros-2.6.0/src/lib.rs","byte_start":8118,"byte_end":8182,"line_start":306,"line_end":306,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"pub fn main(args: TokenStream, item: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:38:65\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[tokio::main]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis function should return `Result` or `Option` to accept `?`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let server = server::ChatServer::new(&address).await?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot use the `?` operator in an async block that returns `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":977,"byte_end":978,"line_start":39,"line_end":39,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"            server.run().await?;","highlight_start":31,"highlight_end":32}],"label":"cannot use the `?` operator in an async block that returns `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":977,"byte_end":978,"line_start":39,"line_end":39,"column_start":31,"column_end":32,"is_primary":false,"text":[{"text":"            server.run().await?;","highlight_start":31,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":"this function should return `Result` or `Option` to accept `?`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[tokio::main]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-macros-2.6.0/src/lib.rs","byte_start":8118,"byte_end":8182,"line_start":306,"line_end":306,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"pub fn main(args: TokenStream, item: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:39:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[tokio::main]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis function should return `Result` or `Option` to accept `?`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            server.run().await?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot use the `?` operator in an async block that returns `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1174,"byte_end":1175,"line_start":44,"line_end":44,"column_start":73,"column_end":74,"is_primary":true,"text":[{"text":"            let mut client = client::ChatClient::connect(&address).await?;","highlight_start":73,"highlight_end":74}],"label":"cannot use the `?` operator in an async block that returns `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1174,"byte_end":1175,"line_start":44,"line_end":44,"column_start":73,"column_end":74,"is_primary":false,"text":[{"text":"            let mut client = client::ChatClient::connect(&address).await?;","highlight_start":73,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":"this function should return `Result` or `Option` to accept `?`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[tokio::main]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-macros-2.6.0/src/lib.rs","byte_start":8118,"byte_end":8182,"line_start":306,"line_end":306,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"pub fn main(args: TokenStream, item: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:44:73\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[tokio::main]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis function should return `Result` or `Option` to accept `?`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let mut client = client::ChatClient::connect(&address).await?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot use the `?` operator in an async block that returns `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1207,"byte_end":1208,"line_start":45,"line_end":45,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"            client.run().await?;","highlight_start":31,"highlight_end":32}],"label":"cannot use the `?` operator in an async block that returns `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1207,"byte_end":1208,"line_start":45,"line_end":45,"column_start":31,"column_end":32,"is_primary":false,"text":[{"text":"            client.run().await?;","highlight_start":31,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":"this function should return `Result` or `Option` to accept `?`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":666,"byte_end":680,"line_start":31,"line_end":31,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[tokio::main]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[tokio::main]","def_site_span":{"file_name":"/home/lopplipp/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-macros-2.6.0/src/lib.rs","byte_start":8118,"byte_end":8182,"line_start":306,"line_end":306,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"pub fn main(args: TokenStream, item: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:45:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[tokio::main]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis function should return `Result` or `Option` to accept `?`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            client.run().await?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot use the `?` operator in an async block that returns `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":755,"byte_end":1238,"line_start":35,"line_end":49,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    match cli.command{","highlight_start":5,"highlight_end":23},{"text":"        Commands::Server { address } => {","highlight_start":1,"highlight_end":42},{"text":"            println!(\" Starting server on {}...\", address);","highlight_start":1,"highlight_end":61},{"text":"            let server = server::ChatServer::new(&address).await?;","highlight_start":1,"highlight_end":67},{"text":"            server.run().await?;","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        Commands::Client { address } => {","highlight_start":1,"highlight_end":42},{"text":"            println!(\" Connecting to server at {}...\", address);","highlight_start":1,"highlight_end":66},{"text":"            let mut client = client::ChatClient::connect(&address).await?;","highlight_start":1,"highlight_end":75},{"text":"            client.run().await?;","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    Ok(());","highlight_start":1,"highlight_end":12}],"label":"expected `Result<(), Error>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":700,"byte_end":719,"line_start":32,"line_end":32,"column_start":20,"column_end":39,"is_primary":false,"text":[{"text":"async fn main() -> std::io::Result<()> {","highlight_start":20,"highlight_end":39}],"label":"expected `Result<(), std::io::Error>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `Result<(), std::io::Error>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try adding an expression at the end of the block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1238,"byte_end":1238,"line_start":49,"line_end":49,"column_start":12,"column_end":12,"is_primary":true,"text":[{"text":"    Ok(());","highlight_start":12,"highlight_end":12}],"label":null,"suggested_replacement":";\n    Ok(())","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:35:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0masync fn main() -> std::io::Result<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `Result<(), std::io::Error>` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    match cli.command{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Commands::Server { address } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            println!(\" Starting server on {}...\", address);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let server = server::ChatServer::new(&address).await?;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Ok(());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|___________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<(), Error>`, found `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m:   expected enum `\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<(), std::io::Error>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found unit type `\u001b[0m\u001b[0m\u001b[1m\u001b[35m()\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try adding an expression at the end of the block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    Ok(());\u001b[0m\u001b[0m\u001b[38;5;10m;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+     Ok(())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 32 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 32 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0277, E0308, E0424, E0425, E0432, E0433, E0573, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0061, E0277, E0308, E0424, E0425, E0432, E0433, E0573, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
